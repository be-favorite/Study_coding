---
title: "<center> 코딩테스트를 위한 파이썬 문법 </center>"
author: "방태모"
date: "2022-04-18"
output: 
 rmdformats::downcute:
editor_options: 
 markdown: 
   wrap: 72
bibliography: references.bib
---

```{=html}
<style>
.math {
 font-size: small;
}
</style>
```
```{r html-setup, include=FALSE}
# echo - Display code in output document (default = TRUE)
# eval - Run code in chunk (default = TRUE)
# knitr::opts_chunk(echo = TRUE)
```

본 스터디 노트는 [@na2020]의 "부록 A. 코딩 테스트를 위한 파이썬 문법"을
기반으로 작성되었습니다. 자세한 내용이 궁금하신 분들은 책을 구매하세요!
한줄기 빛 같은 책입니다. R 마크다운으로 기록할 예정이므로, 우선
[{reticulate}](https://github.com/rstudio/reticulate) 패키지를
명시적으로 불러와주겠습니다.

```{r python-setup}
library(reticulate)
```

# 1 자료형

알고리즘 문제 풀이를 포함하여 모든 프로그래밍은 결국 데이터를 다루는
행위인 만큼, 자료형에 대한 이해는 프로그래밍의 길에 있어서의 첫걸음임.

## 수 자료형

수 자료형(Number)은 코딩 테스트에서 가장 기본적 자료형이며 프로그래밍을
해봤다면 자연스럽게 사용해봤을 것. 데이터는 모두 "수"로 표현할 수 있음.
대부분의 프로그램에서는 일반적으로 정수와 실수가 많이 사용되고, 그
중에서도 정수를 기본으로 사용함. 실제로 코딩 테스트에서도 대부분의 경우
정수형을 다루는 문제가 출제되며, 실수형을 다루어야 하는 문제는 출제
빈도가 낮음.

### 정수형

정수형(Integer)은 정수를 다루는 자료형에 해당. 코딩 테스트에서 출제되는
알고리즘 문제는 대부분 입력과 출력 데이터가 정수형임.

```{python}
a = 1000 #양의 정수
print(a)

a = -7 # 음의 정수
print(a)

a = 0
print(a)
```

### 실수형

실수형(Real Number)은 소주점 아래 데이터를 포함하는 수 자료형으로
파이썬에서는 변수에 소수점을 붙인 수를 대입하면 실수형 변수로 처리함.
단, 소수부가 0이거나, 정수부가 0인 소수는 0을 생략하고 작성할 수 있음.

```{python}
a = 157.93
print(a)

a = -1837.2
print(a)

# 소수부 0일 때 0 생략 가능
a = 5.
print(a)

# 정수부 0일 때 0 생략 가능
a = -.7
print(a)
```

실수형 데이터를 표현하는 방식으로 e나 E를 이용한 지수 표현 방식을 사용할
수 있음. e 다음에 오는 수는 10의 지수부를 의미함. 예를 들어 1e9라고
입력하게 되면, 10의 9제곱이 됨(1,000,000,000)

$$
유효숫자{\rm{e}}^{지수} = 유효숫자 \times 10^{지수}
$$

지수 표현 방식은 코딩 테스트에서 많이 사용 됨. 예컨데, 최단 경로
문제에서는 도달할 수 없는 노드에 대하여 최단 거리를 "무한(INF)"으로
설정하곤 함. 최단 경로로 가능한 최댓값이 10억 미만이라면 무한(INF)을
표현할 때 10억(`1e9`)을 이용할 수 있음. 혹은, `987,654,321`이라 적으면
이게 1e9와 유사할 정도로 크므로 이렇게 적기도 함. 책의 최단 경로 파트
예제에서도 이렇게 표현함:

```{python}
a = 1e9
print(a)

a = 75.25e1
print(a)

a = 3954e-3
print(a)
```

보통 컴퓨터 시스템은 수 데이터를 처리할 때 2진수를 이용하며, 실수를
처리할 때 부동 소수점(Floating-point) 방식을 이용함. 오늘날 가장 널리
쓰이는 IEEE754 표준에서는 실수형을 저장하기 위해 4바이트, 혹은
8바이트라는 고정된 크기의 메모리를 할당하며, 이러한 이유로 인해 현대
컴퓨터 시스템은 대체로 실수 정보를 표현하는 정확도에 한계를 가짐.

예를 들어, 10진수 체계에서는 0.3과 0.6을 더한 값이 0.9로 정확히
떨어지지만, 2진수에서는 0.9를 정확히 표현할 수 있는 방법이 없음. 물론
최대한 0.9와 가깝게 표현하지만 표현한 값이 정확히 0.9가 아닌 미세한
오차가 발생. 일반적으로 코딩 테스트 문제를 풀기 위해 컴퓨터의 내부 동작
방식까지 자세히 알 필요는 없으나 컴퓨터가 실수를 정확히 표현하지
못한다는 사실만은 기억하자. 예컨데, 0.3과 0.6을 더한값이 `0.8999~`로
저장되는 것을 알 수 있음:

```{python}
a = 0.3 + 0.6
print(a)

if a == 0.9:
    print(True)
else:
    print(False)
```

따라서 소수점 값을 비교하는 작업이 필요한 문제라면 실수 값을 비교하지
못해서 원하는 결과를 얻지 못할 수 있음. 이럴 때는 round() 함수를 이용할
수 있음. 흔히 코딩 테스트 문제에서는 실수형 데이터를 비교할 때 소수점
다섯 번째 자리에서 반올림한 결과가 같으면 정답으로 인정하는 식으로
처리함. 그럴 때는 다음과 같이 round() 함수를 이용함:

```{python}
a = 0.3 + 0.6
print(round(a, 4))
if round(a, 4) == 0.9:
    print(True)
else:
    print(False)
```

### 수 자료형의 연산

프로그래밍에서는 사칙연산을 이용해 계산하는데, 이 중 나누기
연산자(`/`)는 파이썬에서 주의해서 사용해야함. 파이썬에서 나누기 연산자는
나눠진 결과를 기본적으로 실수형을로 처리함.

코딩 테스트 문제를 풀 때에는 나머지 연산자(`%`)를 이용할 때가 많은데,
예를 들어 특정한 변수 `a`가 홀수인지 알아볼 때에는 "a가 2로 나눈
나머지가 1인지" 확인해야함. 이럴 때는 나머지 연산자를 사용함. 또한, 나눈
결과에서 몫만을 얻고자 할 때는 몫 연산자(`//`) 이용:

```{python}
a = 7
b = 3

print(a / b)

print(a % b)

print(a // b)
```

이외 거듭제곱 연산자(`**`)를 비롯해 다양한 연산자들이 존재함:

```{python}
a = 5
b = 3
print(a**b)
```

## 리스트 자료형

리스트는 여러 개 데이터를 연속적으로 담아 처리하기 위해 사용할 수 있다.
R의 리스트 자료형을 떠올려서는 안됨. 아마, R의 배열(Array) 자료형과
동일해 보임. 파이썬의 리스트 자료형은 C나 잡아와 같은 프로그래밍 언어의
배열(Array) 기능을 포함하고 있으며, 내부적으로 연결 리스트 자료구조를
채택하고 있어서 append(), remove() 등의 메서드를 지원함. 파이썬 리스트는
C++의 STL vector와 유사하며, 리스트 대신 배열 혹은 테이블이라고 부르기도
함.

### 리스트 만들기

리스트는 대괄호(`[]`)안에 원소를 넣어 초기화하고, 쉼표(`,`)로 원소를
구분함. 리스트의 원소에 접근할 때는 인덱스(Index) 값을 괄호 안에 넣으면
됨. 이때 인덱스는 0부터 시작. 그리고 빈 리스트를 선언하고자 할 때는
`list()` 혹은 간단히 대괄호(`[]`)를 이용할 수 있음.

다음은 1부터 9까지 모든 정수 데이터를 담은 리스트를 만든 다음 특정
인덱스의 원소에 접근하여 출력하는 예제임:

```{python}
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a)

# 인덱스 4, 즉 5번째 원소에 접근
print(a[4])

# 빈 리스트 선언 방법 1
a = list()
print(a)

# 빈 리스트 선언 방법 2
a = []
print(a)
```

코딩 테스트 문제에서는 주로 크기가 N인 1차원 리스트를 초기화해야 하는데
다음 방식으로 초기화하면 편함:

```{python}
# 크기가 N이고, 모든 원소가 0인 1차원 리스트 초기화
n = 10
a = [0] * n
print(a)
```

### 리스트의 인덱싱과 슬라이싱

인덱스 값을 입력해 리스트의 특정 원소에 접근하는 것을 인덱싱이라고 함.
파이썬에서 인덱스값은 양의 정수, 음의 정수 모두 가능하며 음의 정수는
원소를 거꾸로 탐색함. 즉, 인덱스에 `-1`을 넣으면 가장 마지막 원소가
출력됨. 이런 성질을 이용해 인덱싱으로 특정 원소에 접근한 뒤, 그 값을
간단히 바꿀 수도 있음.

```{python}
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a[-1])

print(a[-3])

# 네 번째 원소 값 변경
a[3] = 7
print(a)
```

또한, 리스트에서 연속적 위치를 갖는 원소를 가져와야할 때는
슬라이싱(Slicing)을 이용할 수 있음. 이때는 대괄호 안에 콜론(`:`)을 넣어
시작 인덱스와 (끝 인덱스-1)을 설정할 수 있음. 예를 들어 a 라는 리스트의
두 번째 원소부터 네 번째 원소까지의 모든 데이터를 갖는 리스트를 가져오고
싶다면 `a[1:4]`라고 넣으면 됨. 앞서 말했듯 리스트의 인덱스는 0부터
출발하기에 두 번째 원소의 인데스는 1이 됨. 그리고 끝 인덱스의 경우 1을
뺀 값의 인덱스까지 처리 됨. 따라서, `a[1:4]`라고 작성하면 되는 것임:

```{python}
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]

print(a[1:4])
```

### 리스트 컴프리헨션

리스트 컴프리헨션은 리스트를 초기화하는 방법 중 하나임. 리스트
컴프리헨션을 이용하면 대괄호(`[]`) 안에 조건문과 반복문을 넣는 방식으로
리스트를 초기화 할 수 있음. 간단히 0부터 19까지의 수 중에서 홀수만
포함하는 리스트를 만들고자 할 때 다음과 같이 리스트를 초기화할 수 있음.
이 경우 한 줄의 소스코드로 리스트를 초기화 할 수 있어 매우 편함:

```{python}
array = [i for i in range(20) if i % 2 == 1]

print(array)
```

참고로 위 소스코드를 일반적인 소스코드로 작성하면 다음과 같음:

```{python, eval = FALSE}
array = []
for i in range(20):
    if i % 2 == 1:
        array.append(i)
    
print(array)
```

리스트 컴프리헨션을 이용했을 때의 소스코드가 훨씬 짧고 간결한 것을 알 수
있음. 또 다른 예시로 1부터 9까지 수의 제곱 값을 포함하는 리스트를
만들고자 할 때는 다음과 같이 리스트를 초기화 할 수 있음:

```{python}
array = [i*i for i in range(1, 10)]

print(array)
```

이러한 리스트 컴프리헨션은 코딩 테스트에서 2차원 리스트를 초기화할 때
매우 효과적으로 사용될 수 있음. 예를 들어, $N \times M$ 크기의 2차원
리스트를 초기화할 때는 다음과 같이 사용함.

```{python}
n = 3
m = 4
array = [[0]*m for _ in range(n)]
print(array)
```

여기서 언더바(`_`)는 파이썬에서 반복을 수행하되, 반복을 위한 변수의 값을
무시하고자 할 때 자주 사용한다. 예를 들어 1부터 9까지의 자연수를 더할
때는 왼쪽 예시처럼 작성하지만:

```{python}
summary = 0
for i in range(1, 10):
    summary += i
print(summary)
```

단순히 "Hello World"를 5번 출력할 때는 다음과 같이 언더바를 이용하여
무시할 수 있음.

```{python}
for _ in range(5):
    print("Hello World")
```

참고로 특정 크기의 2차원 리스트를 초기화할 때는 반드시 리스트
컴프리헨션을 이용해야함. 만약 다음과 같이 $N \times M$ 크기의 2차원
리스트를 초기화한다면, 의도하지 않은 결과가 나올 수 있음.

```{python}
# 잘못된 방법
n = 3
m = 4
array = [[0] * m] * n
print(array)

array[1][1] = 5
print(array)
```

위와 같이 잘못된 방법으로 2차원 리스트를 초기화 한 경우, `array[1][1]`의
값을 5로 바꾸었을 뿐인데 3개의 리스트에서 인덱스 1에 해당하는 원소들의
값이 모두 5로 바뀐 것을 확인할 수 있음. 이는 내부적으로 포함된 3개의
리스트가 모두 동일한 객체에 대한 3개의 레퍼런스로 인식되기 때문. 따라서
특정한 크기를 갖는 2차원 리스트를 초기화할 때는 반드시 리스트
컴프리헨션을 이용해야 한다는 적음 기억할 것.

### 리스트 관련 기타 메서드

리스트와 관련한 기타 메서드를 사용하면 리스트 자료형을 효과적으로 이용할
수 있음. 주요 메서드는 다음 표와 같음.

+-------------+-------------+-------------+-------------+
| 메서드명    | 사용법      | 설명        | 시간 복잡도 |
+=============+=============+=============+=============+
| `append()`  | `변수 명    | 리스트에    | $O(1)$      |
|             | .append()`  | 원소 하나   |             |
|             |             | 삽입        |             |
+-------------+-------------+-------------+-------------+
| `sort()`    | `변 수      | 오름차순    | $O(NlogN)$  |
|             | 명.sort()`  | 정렬        |             |
|             |             |             |             |
|             | `           | 내림차순    |             |
|             | 변수  명 .s | 정렬        |             |
|             | ort(rev e r |             |             |
|             | se = True)` |             |             |
+-------------+-------------+-------------+-------------+
| `reverse()` | `변수 명    | 원소 순서   | $O(N)$      |
|             | .reverse()` | 뒤집기      |             |
+-------------+-------------+-------------+-------------+
| `insert()`  | `변수 명.i  | 특정        | $O(N)$      |
|             | n sert (삽  | 인덱스에    |             |
|             | 입할  위 치 | 원소 삽입   |             |
|             |  인덱스 ,   |             |             |
|             | 삽입할 값)` |             |             |
+-------------+-------------+-------------+-------------+
| `count()`   | `변         | 특정 값을   | $O(N)$      |
|             | 수명.co u n | 갖는        |             |
|             | t(특정 값)` | 데이터의    |             |
|             |             | 개수 세기   |             |
+-------------+-------------+-------------+-------------+
| `remove()`  | `변수       | 특정 값을   | $O(N)$      |
|             | 명.rem o v  | 갖는 원소를 |             |
|             | e(특정 값)` | 제거하는데, |             |
|             |             | 값을 가진   |             |
|             |             | 원소가 여러 |             |
|             |             | 개면 하나만 |             |
|             |             | 제거        |             |
+-------------+-------------+-------------+-------------+

```{python}
a = [1, 4, 3]
print("기본 리스트: ", a)

# 리스트에 원소 삽입
a.append(2)
print("삽입: ", a)

# 오름차순 정렬
a.sort()
print("오름차순 정렬: ", a)

# 내림차순 정렬
a.sort(reverse = True)
print("내림차순 정렬: ", a)

# 리스트 원소 뒤집기
a.reverse()
print("원소 뒤집기: ", a)

# 특정 인덱스에 데이터 추가
a.insert(2, 3)
print("인덱스 2에 3추가: ", a)

# 특정 값인 데이터 개수 세기
print("값이 3인 데이터 개수: ", a.count(3))

# 특정 값 데이터 삭제
a.remove(1)
print("값이 1인 데이터 삭제: ", a)
```

이 중 `insert()`와 `append()`, `remove()`를 특히 더 눈여겨 둬야함.

코딩 테스트에서 `insert()`를 사용할 때 원소의 개수가 $N$개면, 시간
복잡도는 $O(N)$이다. 파이썬의 리스트 자료형의 `append()` 함수는
$O(1)$에에 수행되는 데에 반해 `insert()`는 동작이 느리다. 중간에 원소를
삽입한 뒤에, 리스트의 원소 위치를 조정해줘야 하기 때문. 따라서,
`insert()`를 남발하면 시간 초과로 테스트를 통과하지 못할 수도 있음.

`remove()`의 시간 복잡도는 `insert()`와 마찬가지로 `O(N)`임. 리스트
중간에 있는 원소를 삭제하고, 원소 위치를 조정해주어야 하기 때문. 그럼,
특정한 값의 원소를 모두 제거하려면 어떻게 해야하나? 다른 프로그래밍
언어에서는 `remove_all()`과 같은 함수로 간단하게 특정 값을 갖는 모든
원소를 제거할 수 있으나, 파이썬의 경우 그러한 함수를 기본적으로 제공하지
않으므로 다음과 같은 방법을 이용하면 좋다.

다음 코드에서 (1) 부분은 `a`에 포함된 원소를 하나씩 확인하며 그 원소가
`remove_set`에 포함되어 있지않았을 때만 리스트 변수인 `result`에
넣겠다는 의미다. 여기서 중괄호(`{}`)로 묶인 `remove_set`은 이따가 배울
집합 자료형에 해당. 집합 자료형은 이와 같이 '특정 데이터가 이미 등장한
적이 있는지 여부'를 체크할 때 유용함.

```{python}
a = [1, 2, 3, 4, 5, 5, 5]
remove_set = {3, 5}

result = [i for i in a if i not in remove_set] # (1)
print(result)
```

## 문자열 자료형

### 문자열 초기화

문자열 변수를 초기화 할 때는 큰따옴표나 작은 따옴표를 이용함.

```{python}
data = "Hello World"
print(data)

data = "Don't you know \"Python\"?"
print(data)
```

### 문자열 연산

파이썬에서는 문자열 연사도 지원하는데, 문자열 처리시 유용하게 사용 가능.
예를 들어, 문자열 변수에 `+`을 이용하면 단순히 문자열이 더해져서 연결됨.

```{python}
a = "Hello"
b = "World"
print(a + " " + b)
```

문자열 변수에 양의 정수를 곱하면, 문자열이 그 값만큼 여러 번 더해진다.

```{python}
a = "String"
print(a * 3)
```

파이썬의 문자열은 내부적으로 리스트와 같이 처리됨. 즉, 문자열은 여러
개의 문자가 합쳐진 리스트라고 볼 수 있음. 따라서 문자열 데이터에
대해서도 마찬가지로 인덱싱과 슬라이싱을 이용할 수 있음.

```{python}
a = "ABCDEF"
print(a[2:4])
```

## 튜플 자료형

파이썬의 튜플 자료형은 리스트와 거의 비슷한데 다음과 같은 차이가 있음:

-   튜플은 한 번 선언된 값을 변경할 수 없음

-   리스트는 대괄호(`[]`)를 이용하지만, 튜플은 소괄호(`()`)를 이용

예를 들어, 하나의 튜플 데이터를 선언한 다음, 값을 출력하고 튜플의 특정
값을 변경해보면:

```{python, error = TRUE}
a = (1, 2, 3, 4)
print(a)

a[2] = 7
```

말 그대로 대입 연산자(`=`)를 사용해 값을 변경할 수 없다는 의미. 튜플
자료형은 그래프 알고리즘을 구현할 때 자주 사용됨. 예를 들어 다익스트라
최단 경로 알고리즘처럼 최단 경로를 찾아 주는 알고리즘의 내부에서는
우선순위 큐를 이용하는 데 해당 알고리즘에서 우선순위 큐에 한 번 들어간
값은 변경되지 않음. 그래서 그 우선순위 큐에 들어가는 데이터를 튜플로
구성해 소스코드를 작성함. 이렇게 알고리즘을 구현하는 과정에서 일부러
튜플을 이용하게되면 혹여나 자신이 알고리즘을 잘못작성함으로써 변경하면
안 되는 값이 변경되고 있지는 않은지 체크할 수 있음. 또한 튜플은 리스트에
비해 상대적으로 공간 효율적이고, 일반적으로 각 원소의 성질이 서로 다를
때 주로 사용함. 흔히 다익스트라 최단 경로 알고리즘에서는 "비용"과
"노드번호"라는 서로 다른 성질의 데이터를 (비용, 노드번호) 형태로 함께
튜플로 묶어서 관리하는 것이 관례이다.

## 사전 자료형

### 사전 자료형 소개

사전 자료형(Dictionary)은 키(Key)와 값(Value)의 쌍을 데이터로 갖는
자료형임. 앞서 다룬 리스트나 튜플은 값을 순차적으로 저장한다는 특징이
있으나, 사전 자료형은 키-값 쌍을 데이터로 가진다는 점에서, 우리가 원하는
변경 불가능한 데이터를 키로 사용할 수 있음.[^1] 사전 자료형의 예시를
하나 들어보자. 다음과 같이 키-값 쌍으로 구성되는 데이터를 담아야 한다면
어떻게 할 수 있을까?

[^1]: 변경 불가능한 자료형이란 수 자료형, 문자열 자료형, 튜플 자료형과
    같이 한 번 초기화되면 변경이 불가능한 자료형을 의미함. 흔히
    사용되지는 않지만, 튜플 자료형이 사전 자료형의 키로 사용되기도
    하는데, 이는 "Q 22 블록이동하기" 문제 풀이에서 사용된다.

| 키(Key) | 값(Value) |
|---------|-----------|
| 사과    | Apple     |
| 바나나  | Banana    |
| 코코넛  | Coconut   |

키로 한글 단어를 넣고, 값으로 영어 단어를 넣어 "사과"의 영어 단어를
알고싶다면 "사과"라는 키 값을 갖는 데이터에 바로 접근하면 됨. 파이썬의
사전 자료형은 내부적으로 '해시 테이블(Hash Table)'을 이용하므로
기본적으로 데이터의 검색 및 수정에 있어 $O(1)$의 시간에 처리할 수 있음.
이 책에서는 해시 테이블에 대해 깊게 다루지 않을 것이고, 위와 같이 키-값
쌍으로 구성된 데이터를 처리함에 있어서 리스트보다 훨씬 빠르게 동작한다는
점을 기억해라.

```{python}
data = dict()
data["사과"] = "Apple"
data["바나나"] = "Banana"
data["코코넛"] = "Coconut"

print(data)
```

이러한 사전 자료형은 코딩 테스트에서도 자주 사용될 수 있음. 예를 들어,
학생의 번호가 1부터 10,000,000까지로 구성되어 있는 상황에 최대
10,000명의 학생을 선택했다고 가정해보자. 이후에 특정한 학생 번호가
주어졌을 때 해당 학생이 선택되었는지를 어떻게 빠르게 알 수 있을까? 만약
리스트를 이용한다면, 1부터 10,000,000까지의 각 번호가 '선택 되었는 지를
저장할 수 있는' 리스트를 만들어야 함. 다시 말해, 1,000만개 데이터를
저장할 수 있는 리스트를 만들어야 하므로 많은 메모리 공간이 낭비된다. 이
중 999만개 가량의 데이터는 쓰지 않을 것임.

하지만 사전 자료형을 이용하는 경우 1,000만개의 데이터를 담을 필요 없이
10,000개의 데이터만 사전 자료구조에 들어가므로 훨씬 적은 메모리 사용
가능. 실제로 사전을 이용했을 때 문제 풀이가 간결해지는 사례는 2부와
3부의 문제들에서 다루고 있으므로 확인해보면 됨. 사전 자료형에 특정한
원소가 있는지 검사할 때는 '원소 in 사전'의 형태를 이용하면 됨. 이는
리스트나 튜플에 대해서도 사용할 수 있는 문법임.[^2]

[^2]: 파이썬에서 리스트, 문자열, 튜플 등 순차적 정보를 담는 자료형을
    iterable 자료형이라고 함. in 문법은 이러한 iterable 자료형에 모두
    사용 가능.

```{python}
if '사과' in data:
    print("'사과'를 키로 갖는 데이터가 존재함.")
```

### 사전 자료형 관련 함수

대표적으로 키와 값을 별도로 뽑아내는 함수가 있음. 키만 뽑아서 리스트로
이용할 때는 `keys()`, 값만 뽑아서 리스트로 이용할 때는 `values()`를
이용할 수 있음.

```{python}
key_list = data.keys()
value_list = data.values()
print(key_list)
print(value_list)

# 각 키에 따른 값을 하나씩 출력
for key in key_list:
    print(data[key])
```

## 집합 자료형

### 집합 자료형 소개

집합(Set)은 기본적으로 리스트 또는 문자열을 이용해 만들 수 있는데,
집합은 다음과 같은 특징이 있음:

-   중복 허용 X

-   순서 X

기본에 다루었던 리스트나 튜플은 순서가 있기 때문에 인덱싱을 통해
자료형의 값을 얻을 수 있었음. 반면에 사전 자료형과 집합 자료형은 순서가
없기 때문에 인덱싱으로 값을 얻을 수 없다는 특징이 있음. 이와 더불어 집합
자료형에서는 키가 존재하지 않고, 값 데이터만을 담게 됨. 특정 원소가
존재하는지를 검사하는 연산의 시간 복잡도는 사전 자료형과 마찬가지로
`O(1)`임.

방금 사전 자료형에 대해 다룰 때 언급했던 '학생 번호가 주어졌을 때 해당
학생이 선택되었는지 여부를 출력하는 문제'에서도 집합 자료형이 효과적으로
사용될 수 있음. 이와 같이 집합 자료형의 사용 방법을 알아두면 효과적으로
이용될 때가 있음. 특히, '특정한 데이터가 이미 등장한 적이 있는 지
여부'를 체크할 때 매우 효과적. 집합 자료형을 초기화 할 때는 `set()`을
이용하거나, 중괄호(`{}`) 안에 각 원소를 콤마(`,`)를 기준으로 구분해서
넣으면 됨.

```{python}
data = set([1, 1, 2, 3, 4, 4, 5])
print(data)

data = {1, 1, 2, 3, 4, 4, 5}
print(data)
```

### 집합 자료형의 연산

집합 연산으로는 합집합(`|`), 교집합(`&`), 차집합(`-`)이 가능.

```{python}
a = {1, 2, 3, 4, 5}
b = {3, 4, 5, 6, 7}

print(a | b)
print(a & b)
print(a - b)
```

### 집합 자료형 관련 함수

-   `add()`: 하나의 집합 데이터에 값을 추가
-   `update()`: 여러 개의 값을 한꺼번에 추가
-   `remove()`: 특정 값 제거

이때 `add()`와 `remove()` 함수는 모두 시간 복잡도가 `O(1)`임. 그 이유는,
집합 자료형에 순서가 없기 때문으로 추정됨.

```{python}
data = {1, 2, 3}
print(data)

data.add(4)
print(data)

data.update([5, 6])
print(data)

data.remove(3)
print(data)
```

# 2 조건문

조건문을 이용하면 조건에 따라 프로그램의 로직을 설정할 수 있음. 예를
들어 다음과 같이 어떤 변수의 값이 10 이상일 때에 한해서만 변수의 값을
출력할 수 있음:

```{python}
x = 15

if x >= 10:
    print(x)
```

파이썬에서 조건문은 `if ~ elif ~ else`을 이용함. `elif` 또는 `else`는
경우에 따라 사용하지 않아도 됨.

```{python, eval = FALSE}
if 조건문 1:
    조건문 1이 True 일때 실행 되는 코드
elif 조건문 2:
    조건문 1에 해당하지 않고, 조건문 2가 True일 때 실행되는 코드
else:
    위의 모든 조건문이 True 값이 아닐 때 실행되는 코드
```

다음과 같이 성적 구간에 따른 학점 정보를 출력한다고 가정해보자. 이때 if
\~ elif \~ else 문을 효과적으로 사용할 수 있음.

-   성적 90점 이상: A
-   성적 90점 미만, 80점 이상: B
-   성적 80점 미만, 70점 이상: C
-   성적 70점 미만: F

```{python}
score = 85
if score >= 90:
    print("학점: A")
elif score >= 80:
    print("학점: B")
elif score >= 70:
    print("학점: C")
else:
    print("학점: F")
```

조건문 작성 시 코드의 블록을 들여쓰기로 설정한다는 점을 기억해라.
들여쓰기가 같은 부분은 함께 실행됨. 다음 코드의 (2)는 조건문과 상관없이
무조건 실행되는 부분.

```{python}
score = 90
if score >= 70:
    print('성적이 70점 이상입니다.')
    if score >= 90:
        print('우수한 성적입니다.')
else:
    print('성적이 70점 미만입니다.')
    print('조금 더 분발하세요.')
    
print('프로그램을 종료합니다.')
```

파이썬에서 들여쓰기는 스페이스바 4번을 입력해 작성함. 탭을 사용하는 쪽과
논쟁이 활발하나, 파이썬 커뮤니티에서는 4개의 공백문자를 사용하는 것이
사실상의 표준.

### 비교 연산자

R과 같음. 편의상 생략.

### 논리 연산자

논리 연산자(logical operators)는 2개의 논리 값 사이의 연산을 수행할 때
사용하는데 파이썬에는 3가지 논리 연산자가 있음. `and`와 `or`은 R과
같으며, `not`만 알아두면 될 듯. `not X`는 말 그대로, `X`가 거짓(False)일
때 참(True)임.

### 기타 연산자

파이썬에서는 추가적으로 `in` 연산자와 `not in` 연산자를 제공. 여러 개의
데이터를 담는 자료형으로 리스트, 튜플, 문자열, 사전과 같은 자료형 존재.
이러한 자료형은 여러 개 데이터를 담고 있어, 자료형 안에 어떤 값이
존재하는지 확인하는 연산이 필요할 때가 있음. 또한, 파이썬에서는 조건문의
값이 참(True)이라고 해도, 아무것도 처리하고 싶지 않을 때 `pass`문을
만들어 이용가능. 에를 들어, 코드를 작성하며 디버깅하는 과정에서 일단
조건문의 형태만 만들어 놓고 조건문을 처리하는 부분은 비워놓고 싶을 때가
있을 수 있음:

```{python}
score = 85

if score >= 80:
    pass # 나중에 작성할 소스코드
else:
    print("성적이 80점 미만입니다.")

print("프로그램을 종료합니다.")
```

조건문에서 실행될 소스코드가 한 줄이면, 굳이 줄바꿈 하지 않고 간략히
표현도 가능.

```{python}
score = 85
if score >= 80: result = "Success"
else: result = "Fail"
```

더 나아가 조건부 표현식(Conditional Expression) 이용시, `if ~ else`문을
한 줄에 작성해 사용 가능.

```{python}
score = 85
result = "Success" if score >= 80 else "Fail"

print(result)
```

특히 조건부 표현식은 리스트에 있는 원소의 값을 변경해, 또 다른 리스트를
만들고자 할 때 매우 간결하게 사용 가능. 예를 들어 리스트에서 특정 원소
값만을 없앤다고 해보자. 원래 일반적인 조건문을 이용하면 다음과 같이
작성해야함.

```{python}
a = [1, 2, 3, 4, 5, 5, 5]
remove_set = {3, 5}

result = []
for i in a:
    if i not in remove_set:
        result.append(i)
        
print(i)
```

다음과 같이 간단히 작성 가능.

```{python}
a = [1, 2, 3, 4, 5, 5, 5]
remove_set = {3, 5}

result = [i for i in a if i not in remove_set]

print(result)
```

그리고, 파이썬에서 한가지 특이한 점은 조건문 안에서 수학의 부등식을
그대로 사용할 수 있다는 점이다. 예를 들어, 다음과 같은 코드가 있다고
하자.

```{python}
x = 15
if x > 0 and x < 20:
    print("x는 0이상 20 미만의 수입니다.")
```

이는 다음과 같다:

```{python}
x = 15
if 0 < x < 20:
    print("x는 0이상 20 미만의 수입니다.")
```

## 반복문

------------------------------------------------------------------------

### Reference
